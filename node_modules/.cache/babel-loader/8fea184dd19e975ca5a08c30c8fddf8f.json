{"ast":null,"code":"/*\n\tHebcal - A Jewish Calendar Generator\n\tCopyright (C) 1994-2004  Danny Sadinoff\n\tPortions Copyright (c) 2002 Michael J. Radwin. All Rights Reserved.\n\n\thttps://github.com/hebcal/hebcal-js\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program. If not, see <http://www.gnu.org/licenses/>.\n\n\tDanny Sadinoff can be reached at danny@sadinoff.com\n\n\tMichael Radwin has made significant contributions as a result of\n\tmaintaining hebcal.com.\n\n\tThe JavaScript code was completely rewritten in 2014 by Eyal Schachter.\n */\nvar c = require('./common'),\n    greg = require('./greg'),\n    suncalc = require('suncalc'),\n    cities = require('./cities'),\n    gematriya = require('gematriya');\n\nsuncalc.addTime(-16.1, 'alot_hashachar', 0);\nsuncalc.addTime(-11.5, 'misheyakir', 0);\nsuncalc.addTime(-10.2, 'misheyakir_machmir', 0);\nsuncalc.addTime(-8.5, 0, 'tzeit'); // for minifying optimizations\n\nvar getFullYear = 'getFullYear',\n    getMonth = 'getMonth',\n    getDate = 'getDate',\n    getTime = 'getTime',\n    abs = 'abs',\n    hour = 'hour',\n    months = c.months,\n    TISHREI = months.TISHREI,\n    MONTH_CNT = c.MONTH_CNT,\n    daysInMonth = c.daysInMonth,\n    dayOnOrBefore = c.dayOnOrBefore,\n    prototype = HDate.prototype;\n\nfunction HDate(day, month, year) {\n  var me = this;\n\n  switch (arguments.length) {\n    case 0:\n      return new HDate(new Date());\n\n    case 1:\n      if (typeof day == 'undefined') {\n        return new HDate();\n      } else if (day instanceof Date) {\n        // we were passed a Gregorian date, so convert it\n        var d = abs2hebrew(greg.greg2abs(day));\n        /*if (d.sunset() < day) {\n        \td = d.next();\n        }*/\n\n        return d;\n      } else if (day instanceof HDate) {\n        var d = new HDate(day[getDate](), day[getMonth](), day[getFullYear]());\n        d.il = day.il;\n        d.setLocation(d.lat, d.long);\n        return d;\n      } else if (typeof day == 'string') {\n        switch (day.toLowerCase().trim()) {\n          case 'today':\n            return new HDate();\n\n          case 'yesterday':\n            return new HDate().prev();\n\n          case 'tomorrow':\n            return new HDate().next();\n        }\n\n        if (/\\s/.test(day)) {\n          var s = day.split(/\\s+/);\n\n          if (s.length == 2) {\n            return new HDate(s[0], s[1]);\n          } else if (s.length == 3) {\n            return new HDate(s[0], s[1], s[2]);\n          } else if (s.length == 4) {\n            // should only be if s[1] is Adar\n            if (/i/i.test(s[2])) {\n              // Using I[I] syntax\n              s[2] = s[2].length;\n            } // otherwise using 1|2 syntax\n\n\n            return new HDate(s[0], s[1] + s[2], s[3]);\n          }\n        }\n      } else if (typeof day == 'number') {\n        // absolute date\n        return abs2hebrew(day);\n      }\n\n      throw new TypeError('HDate called with bad argument');\n\n    case 2:\n      return new HDate(day, month, new HDate()[getFullYear]());\n\n    case 3:\n      me.day = me.month = 1;\n      me.year = c.dayYearNum(year);\n      me.setMonth(c.monthNum(month));\n      me.setDate(c.dayYearNum(day));\n      break;\n\n    default:\n      throw new TypeError('HDate called with bad arguments');\n  }\n\n  return me.setLocation.apply(me, HDate.defaultLocation);\n}\n\nHDate.defaultLocation = [0, 0];\nObject.defineProperty(HDate, 'defaultCity', {\n  enumerable: true,\n  configurable: true,\n  get: function () {\n    return cities.nearest(HDate.defaultLocation[0], HDate.defaultLocation[1]);\n  },\n  set: function (city) {\n    HDate.defaultLocation = cities.getCity(city).slice(0, 2);\n  }\n});\n\nfunction fix(date) {\n  fixMonth(date);\n  fixDate(date);\n}\n\nfunction fixDate(date) {\n  if (date.day < 1) {\n    if (date.month == TISHREI) {\n      date.year -= 1;\n    }\n\n    date.day += daysInMonth(date.month, date.year);\n    date.month -= 1;\n    fix(date);\n  }\n\n  if (date.day > daysInMonth(date.month, date.year)) {\n    if (date.month == months.ELUL) {\n      date.year += 1;\n    }\n\n    date.day -= daysInMonth(date.month, date.year);\n    date.month += 1;\n    fix(date);\n  }\n\n  fixMonth(date);\n}\n\nfunction fixMonth(date) {\n  if (date.month == months.ADAR_II && !date.isLeapYear()) {\n    date.month -= 1; // to Adar I\n\n    fix(date);\n  }\n\n  if (date.month < 1) {\n    date.month += MONTH_CNT(date.year);\n    date.year -= 1;\n    fix(date);\n  }\n\n  if (date.month > MONTH_CNT(date.year)) {\n    date.month -= MONTH_CNT(date.year);\n    date.year += 1;\n    fix(date);\n  }\n}\n\nprototype[getFullYear] = function () {\n  return this.year;\n};\n\nprototype.isLeapYear = function () {\n  return c.LEAP(this.year);\n};\n\nprototype[getMonth] = function () {\n  return this.month;\n};\n\nprototype.getTishreiMonth = function () {\n  var nummonths = MONTH_CNT(this[getFullYear]());\n  return (this[getMonth]() + nummonths - 6) % nummonths || nummonths;\n};\n\nprototype.daysInMonth = function () {\n  return daysInMonth(this[getMonth](), this[getFullYear]());\n};\n\nprototype[getDate] = function () {\n  return this.day;\n};\n\nprototype.getDay = function () {\n  return this.greg().getDay();\n};\n\nprototype.setFullYear = function (year) {\n  this.year = year;\n  fix(this);\n  return this;\n};\n\nprototype.setMonth = function (month) {\n  this.month = c.monthNum(month);\n  fix(this);\n  return this;\n};\n\nprototype.setTishreiMonth = function (month) {\n  return this.setMonth((month + 6) % MONTH_CNT(this[getFullYear]()) || 13);\n};\n\nprototype.setDate = function (date) {\n  this.day = date;\n  fix(this);\n  return this;\n};\n/* convert hebrew date to absolute date */\n\n/* Absolute date of Hebrew DATE.\n   The absolute date is the number of days elapsed since the (imaginary)\n   Gregorian date Sunday, December 31, 1 BC. */\n\n\nfunction hebrew2abs(d) {\n  var m,\n      tempabs = d[getDate](),\n      year = d[getFullYear]();\n\n  if (d[getMonth]() < TISHREI) {\n    for (m = TISHREI; m <= MONTH_CNT(year); m++) {\n      tempabs += daysInMonth(m, year);\n    }\n\n    for (m = months.NISAN; m < d[getMonth](); m++) {\n      tempabs += daysInMonth(m, year);\n    }\n  } else {\n    for (m = TISHREI; m < d[getMonth](); m++) {\n      tempabs += daysInMonth(m, year);\n    }\n  }\n\n  return c.hebElapsedDays(year) - 1373429 + tempabs;\n}\n\nfunction abs2hebrew(d) {\n  var mmap = [months.KISLEV, months.TEVET, months.SHVAT, months.ADAR_I, months.NISAN, months.IYYAR, months.SIVAN, months.TAMUZ, TISHREI, TISHREI, TISHREI, months.CHESHVAN],\n      hebdate,\n      gregdate,\n      month,\n      year;\n\n  if (d >= 10555144) {\n    throw new RangeError(\"parameter to abs2hebrew \" + d + \" out of range\");\n  }\n\n  gregdate = greg.abs2greg(d);\n  hebdate = new HDate(1, TISHREI, year = 3760 + gregdate[getFullYear]());\n\n  while (d >= hebrew2abs(hebdate.setFullYear(year + 1))) {\n    year++;\n  }\n\n  if (year > 4634 && year < 10666) {\n    // optimize search\n    month = mmap[gregdate[getMonth]()];\n  } else {\n    // we're outside the usual range, so assume nothing about Hebrew/Gregorian calendar drift...\n    month = TISHREI;\n  }\n\n  while (d > hebrew2abs(hebdate = new HDate(daysInMonth(month, year), month, year))) {\n    month = month % MONTH_CNT(year) + 1;\n  }\n\n  return hebdate.setLocation.apply(hebdate.setDate(d - hebrew2abs(hebdate.setDate(1)) + 1), HDate.defaultLocation);\n}\n\nprototype.greg = function () {\n  return greg.abs2greg(hebrew2abs(this));\n};\n\nprototype.gregEve = function () {\n  return this.prev().sunset();\n};\n\nprototype[abs] = function () {\n  return hebrew2abs(this);\n};\n\nprototype.toString = function (o) {\n  return c.LANG([this[getDate](), null, gematriya(this[getDate]())], o) + ' ' + this.getMonthName(o) + ' ' + c.LANG([this[getFullYear](), null, gematriya(this[getFullYear]())], o);\n};\n\nprototype.getMonthName = function (o) {\n  return c.LANG(c.monthNames[+this.isLeapYear()][this[getMonth]()], o);\n};\n\nprototype.setCity = function (city) {\n  return this.setLocation(cities.getCity(city));\n};\n\nprototype.setLocation = function (lat, lon) {\n  if (typeof lat == 'object' && !Array.isArray(lat)) {\n    lon = lat.long;\n    lat = lat.lat;\n  }\n\n  if (Array.isArray(lat) && typeof lon == 'undefined') {\n    lon = lat[1];\n    lat = lat[0];\n  }\n\n  if (Array.isArray(lat)) {\n    lat = (lat[0] * 60 + lat[1]) / 60;\n  }\n\n  if (Array.isArray(lon)) {\n    lon = (lon[0] * 60 + lon[1]) / 60;\n  }\n\n  if (typeof lat != 'number') {\n    throw new TypeError('incorrect lat type passed to HDate.setLocation()');\n  }\n\n  if (typeof lon != 'number') {\n    throw new TypeError('incorrect long type passed to HDate.setLocation()');\n  }\n\n  this.lat = lat;\n  this.long = lon;\n  this.il = cities.getCity(cities.nearest(lat, lon))[2];\n  return this;\n};\n\nfunction suntime(hdate) {\n  // reset the date to midday before calling suncalc api\n  // https://github.com/mourner/suncalc/issues/11\n  var date = hdate.greg();\n  return suncalc.getTimes(new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0, 0, 0), hdate.lat, hdate.long);\n}\n\nprototype.sunrise = function () {\n  return suntime(this).sunrise;\n};\n\nprototype.sunset = function () {\n  return suntime(this).sunset;\n};\n\nprototype[hour] = function () {\n  return (this.sunset() - this.sunrise()) / 12; // ms in hour\n};\n\nprototype.hourMins = function () {\n  // hour in ms / (1000 ms in s * 60 s in m) = mins in halachic hour\n  return this[hour]() / (1000 * 60);\n};\n\nprototype.nightHour = function () {\n  return (this.sunrise() - this.gregEve()) / 12; // ms in hour\n};\n\nprototype.nightHourMins = function () {\n  // hour in ms / (1000 ms in s * 60 s in m) = mins in halachic hour\n  return this.nightHour() / (1000 * 60);\n};\n\nfunction hourOffset(hdate, hours) {\n  return new Date(hdate.sunrise()[getTime]() + hdate[hour]() * hours);\n}\n\nvar zemanim = {\n  chatzot: function (hdate) {\n    return hourOffset(hdate, 6);\n  },\n  chatzot_night: function (hdate) {\n    return new Date(hdate.sunrise()[getTime]() - hdate.nightHour() * 6);\n  },\n  alot_hashachar: function (hdate) {\n    return suntime(hdate).alot_hashachar;\n  },\n  alot_hashacher: function (hdate) {\n    return suntime(hdate).alot_hashachar;\n  },\n  misheyakir: function (hdate) {\n    return suntime(hdate).misheyakir;\n  },\n  misheyakir_machmir: function (hdate) {\n    return suntime(hdate).misheyakir_machmir;\n  },\n  sof_zman_shma: function (hdate) {\n    // Gra\n    return hourOffset(hdate, 3);\n  },\n  sof_zman_tfilla: function (hdate) {\n    // Gra\n    return hourOffset(hdate, 4);\n  },\n  mincha_gedola: function (hdate) {\n    return hourOffset(hdate, 6.5);\n  },\n  mincha_ketana: function (hdate) {\n    return hourOffset(hdate, 9.5);\n  },\n  plag_hamincha: function (hdate) {\n    return hourOffset(hdate, 10.75);\n  },\n  tzeit: function (hdate) {\n    return suntime(hdate).tzeit;\n  },\n  neitz_hachama: function (hdate) {\n    return hdate.sunrise();\n  },\n  shkiah: function (hdate) {\n    return hdate.sunset();\n  }\n};\n\nprototype.getZemanim = function () {\n  return c.map(zemanim, function (z) {\n    return z(this);\n  }, this);\n};\n\nHDate.addZeman = function (zeman, func) {\n  zemanim[zeman] = func;\n};\n\nprototype.next = function () {\n  return abs2hebrew(this.abs() + 1).setLocation(this.lat, this.long);\n};\n\nprototype.prev = function () {\n  return abs2hebrew(this.abs() - 1).setLocation(this.lat, this.long);\n};\n\nprototype.isSameDate = function (other) {\n  if (other instanceof HDate) {\n    if (other[getFullYear]() == -1) {\n      other = new HDate(other).setFullYear(this[getFullYear]());\n    }\n\n    return this[abs]() == other[abs]();\n  }\n\n  return false;\n};\n\nfunction onOrBefore(day, t, offset) {\n  return new HDate(dayOnOrBefore(day, t[abs]() + offset)).setLocation(t.lat, t.long);\n}\n\nprototype.before = function (day) {\n  return onOrBefore(day, this, -1);\n};\n\nprototype.onOrBefore = function (day) {\n  return onOrBefore(day, this, 0);\n};\n\nprototype.nearest = function (day) {\n  return onOrBefore(day, this, 3);\n};\n\nprototype.onOrAfter = function (day) {\n  return onOrBefore(day, this, 6);\n};\n\nprototype.after = function (day) {\n  return onOrBefore(day, this, 7);\n};\n\nmodule.exports = HDate;","map":null,"metadata":{},"sourceType":"script"}