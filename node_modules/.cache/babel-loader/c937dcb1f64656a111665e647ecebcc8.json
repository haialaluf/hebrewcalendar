{"ast":null,"code":"/*\n\tHebcal - A Jewish Calendar Generator\n\tCopyright (C) 1994-2004  Danny Sadinoff\n\tPortions Copyright (c) 2002 Michael J. Radwin. All Rights Reserved.\n\n\thttps://github.com/hebcal/hebcal-js\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program. If not, see <http://www.gnu.org/licenses/>.\n\n\tDanny Sadinoff can be reached at danny@sadinoff.com\n\n\tMichael Radwin has made significant contributions as a result of\n\tmaintaining hebcal.com.\n\n\tThe JavaScript code was completely rewritten in 2014 by Eyal Schachter.\n */\nvar gematriya = require('gematriya');\n\nvar charCodeAt = 'charCodeAt';\nvar months = exports.months = {\n  NISAN: 1,\n  IYYAR: 2,\n  SIVAN: 3,\n  TAMUZ: 4,\n  AV: 5,\n  ELUL: 6,\n  TISHREI: 7,\n  CHESHVAN: 8,\n  KISLEV: 9,\n  TEVET: 10,\n  SHVAT: 11,\n  ADAR_I: 12,\n  ADAR_II: 13\n};\nvar monthNames = [[\"\", 0, \"\"], [\"Nisan\", 0, \"ניסן\"], [\"Iyyar\", 0, \"אייר\"], [\"Sivan\", 0, \"סיון\"], [\"Tamuz\", 0, \"תמוז\"], [\"Av\", 0, \"אב\"], [\"Elul\", 0, \"אלול\"], [\"Tishrei\", 0, \"תשרי\"], [\"Cheshvan\", 0, \"חשון\"], [\"Kislev\", 0, \"כסלו\"], [\"Tevet\", 0, \"טבת\"], [\"Sh'vat\", 0, \"שבט\"]];\nexports.monthNames = [monthNames.concat([[\"Adar\", 0, \"אדר\"], [\"Nisan\", 0, \"ניסן\"]]), monthNames.concat([[\"Adar 1\", 0, \"אדר א'\"], [\"Adar 2\", 0, \"אדר ב'\"], [\"Nisan\", 0, \"ניסן\"]])];\nexports.days = {\n  SUN: 0,\n  MON: 1,\n  TUE: 2,\n  WED: 3,\n  THU: 4,\n  FRI: 5,\n  SAT: 6\n};\n\nexports.LANG = function (str, opts) {\n  return opts == 'h' && str[2] || opts == 'a' && str[1] || str[0];\n};\n\nfunction LEAP(x) {\n  return (1 + x * 7) % 19 < 7;\n}\n\nexports.LEAP = LEAP;\n\nexports.MONTH_CNT = function (x) {\n  return 12 + LEAP(x); // boolean is cast to 1 or 0\n};\n\nexports.daysInMonth = function (month, year) {\n  return 30 - (month == months.IYYAR || month == months.TAMUZ || month == months.ELUL || month == months.TEVET || month == months.ADAR_II || month == months.ADAR_I && !LEAP(year) || month == months.CHESHVAN && !lngChesh(year) || month == months.KISLEV && shrtKis(year));\n};\n\nexports.monthNum = function (month) {\n  return typeof month === 'number' ? month : month[charCodeAt](0) >= 1488 && month[charCodeAt](0) <= 1514 && /('|\")/.test(month) ? gematriya(month) : month[charCodeAt](0) >= 48 && month[charCodeAt](0) <= 57\n  /* number */\n  ? parseInt(month, 10) : monthFromName(month);\n};\n\nexports.dayYearNum = function (str) {\n  return typeof str === 'number' ? str : str[charCodeAt](0) >= 1488 && str[charCodeAt](0) <= 1514 ? gematriya(str, true) : parseInt(str, 10);\n};\n/* Days from sunday prior to start of Hebrew calendar to mean\n   conjunction of Tishrei in Hebrew YEAR\n */\n\n\nfunction hebElapsedDays(hYear) {\n  // borrowed from original JS\n  var m_elapsed = 235 * Math.floor((hYear - 1) / 19) + 12 * ((hYear - 1) % 19) + Math.floor(((hYear - 1) % 19 * 7 + 1) / 19);\n  var p_elapsed = 204 + 793 * (m_elapsed % 1080);\n  var h_elapsed = 5 + 12 * m_elapsed + 793 * Math.floor(m_elapsed / 1080) + Math.floor(p_elapsed / 1080);\n  var parts = p_elapsed % 1080 + 1080 * (h_elapsed % 24);\n  var day = 1 + 29 * m_elapsed + Math.floor(h_elapsed / 24);\n  var alt_day = day + (parts >= 19440 || 2 == day % 7 && parts >= 9924 && !LEAP(hYear) || 1 == day % 7 && parts >= 16789 && LEAP(hYear - 1));\n  return alt_day + (alt_day % 7 === 0 || alt_day % 7 == 3 || alt_day % 7 == 5);\n}\n\nexports.hebElapsedDays = hebElapsedDays;\n/* Number of days in the hebrew YEAR */\n\nfunction daysInYear(year) {\n  return hebElapsedDays(year + 1) - hebElapsedDays(year);\n}\n\nexports.daysInYear = daysInYear;\n/* true if Cheshvan is long in Hebrew YEAR */\n\nfunction lngChesh(year) {\n  return daysInYear(year) % 10 == 5;\n}\n\nexports.lngChesh = lngChesh;\n/* true if Kislev is short in Hebrew YEAR */\n\nfunction shrtKis(year) {\n  return daysInYear(year) % 10 == 3;\n}\n\nexports.shrtKis = shrtKis;\n\nfunction monthFromName(c) {\n  /*\n  the Hebrew months are unique to their second letter\n  N         Nisan  (November?)\n  I         Iyyar\n  E        Elul\n  C        Cheshvan\n  K        Kislev\n  1        1Adar\n  2        2Adar\n  Si Sh     Sivan, Shvat\n  Ta Ti Te Tamuz, Tishrei, Tevet\n  Av Ad    Av, Adar\n  \tאב אד אי אל   אב אדר אייר אלול\n  ח            חשון\n  ט            טבת\n  כ            כסלו\n  נ            ניסן\n  ס            סיון\n  ש            שבט\n  תמ תש        תמוז תשרי\n  */\n  switch (c.toLowerCase()[0]) {\n    case 'n':\n    case 'נ':\n      return c.toLowerCase()[1] == 'o' ?\n      /* this catches \"november\" */\n      0 : months.NISAN;\n\n    case 'i':\n      return months.IYYAR;\n\n    case 'e':\n      return months.ELUL;\n\n    case 'c':\n    case 'ח':\n      return months.CHESHVAN;\n\n    case 'k':\n    case 'כ':\n      return months.KISLEV;\n\n    case 's':\n      switch (c.toLowerCase()[1]) {\n        case 'i':\n          return months.SIVAN;\n\n        case 'h':\n          return months.SHVAT;\n\n        default:\n          return 0;\n      }\n\n    case 't':\n      switch (c.toLowerCase()[1]) {\n        case 'a':\n          return months.TAMUZ;\n\n        case 'i':\n          return months.TISHREI;\n\n        case 'e':\n          return months.TEVET;\n      }\n\n      break;\n\n    case 'a':\n      switch (c.toLowerCase()[1]) {\n        case 'v':\n          return months.AV;\n\n        case 'd':\n          if (/(1|[^i]i|a|א)$/i.test(c)) {\n            return months.ADAR_I;\n          }\n\n          return months.ADAR_II;\n        // else assume sheini\n      }\n\n      break;\n\n    case 'ס':\n      return months.SIVAN;\n\n    case 'ט':\n      return months.TEVET;\n\n    case 'ש':\n      return months.SHVAT;\n\n    case 'א':\n      switch (c.toLowerCase()[1]) {\n        case 'ב':\n          return months.AV;\n\n        case 'ד':\n          if (/(1|[^i]i|a|א)$/i.test(c)) {\n            return months.ADAR_I;\n          }\n\n          return months.ADAR_II;\n        // else assume sheini\n\n        case 'י':\n          return months.IYYAR;\n\n        case 'ל':\n          return months.ELUL;\n      }\n\n      break;\n\n    case 'ת':\n      switch (c.toLowerCase()[1]) {\n        case 'מ':\n          return months.TAMUZ;\n\n        case 'ש':\n          return months.TISHREI;\n      }\n\n      break;\n  }\n\n  return 0;\n}\n\n;\nexports.monthFromName = monthFromName;\n/* Note: Applying this function to d+6 gives us the DAYNAME on or after an\n * absolute day d.  Similarly, applying it to d+3 gives the DAYNAME nearest to\n * absolute date d, applying it to d-1 gives the DAYNAME previous to absolute\n * date d, and applying it to d+7 gives the DAYNAME following absolute date d.\n\n**/\n\nexports.dayOnOrBefore = function (day_of_week, absdate) {\n  return absdate - (absdate - day_of_week) % 7;\n};\n\nexports.map = function (self, fun, thisp) {\n  // originally written for http://github.com/Scimonster/localbrowse\n  if (self === null || typeof fun != 'function') {\n    throw new TypeError();\n  }\n\n  var t = Object(self);\n  var res = {};\n\n  for (var i in t) {\n    if (t.hasOwnProperty(i)) {\n      res[i] = fun.call(thisp, t[i], i, t);\n    }\n  }\n\n  if (Array.isArray(self) || typeof self == 'string') {\n    // came as an array, return an array\n    var arr = [];\n\n    for (i in res) {\n      arr[Number(i)] = res[i];\n    }\n\n    res = filter(arr, true); // for...in isn't guaranteed to give any meaningful order\n\n    if (typeof self == 'string') {\n      res = res.join('');\n    }\n  }\n\n  return res;\n};\n\nfunction filter(self, fun, thisp) {\n  if (self === null) {\n    throw new TypeError('self is null');\n  }\n\n  switch (typeof fun) {\n    case 'function':\n      break;\n    // do nothing\n\n    case 'string':\n    case 'number':\n      return self[fun];\n    // str/num is just the property\n\n    case 'boolean':\n      // boolean shortcuts to filter only truthy/falsy values\n      if (fun) {\n        fun = function (v) {\n          return v;\n        };\n      } else {\n        fun = function (v) {\n          return !v;\n        };\n      }\n\n      break;\n\n    case 'object':\n      var funOrig = fun; // save it\n\n      if (fun instanceof RegExp) {\n        // test the val against the regex\n        fun = function (v) {\n          return funOrig.test(v);\n        };\n\n        break;\n      } else if (Array.isArray(fun)) {\n        // keep these keys\n        fun = function (v, k) {\n          return funOrig.indexOf(k) > -1;\n        };\n\n        break;\n      }\n\n    default:\n      throw new TypeError('fun is not a supported type');\n  }\n\n  var res = {};\n  var t = Object(self);\n\n  for (var i in t) {\n    if (t.hasOwnProperty(i)) {\n      var val = t[i]; // in case fun mutates it\n\n      if (fun.call(thisp, val, i, t)) {\n        // define property on res in the same manner as it was originally defined\n        var props = Object.getOwnPropertyDescriptor(t, i);\n        props.value = val;\n        Object.defineProperty(res, i, props);\n      }\n    }\n  }\n\n  if (Array.isArray(self) || typeof self == 'string') {\n    // came as an array, return an array\n    var arr = [];\n\n    for (i in res) {\n      arr[Number(i)] = res[i];\n    }\n\n    res = arr.filter(function (v) {\n      return v;\n    }); // for...in isn't guaranteed to give any meaningful order\n    // can't use c.filter(arr,true) here because that would infitely recurse\n\n    if (typeof self == 'string') {\n      res = res.join('');\n    }\n  }\n\n  return res;\n}\n\nexports.filter = filter;\n\nexports.range = function (start, end, step) {\n  step = step || 1;\n\n  if (step < 0) {\n    step = 0 - step;\n  }\n\n  var arr = [],\n      i = start;\n\n  if (start < end) {\n    for (; i <= end; i += step) {\n      arr.push(i);\n    }\n  } else {\n    for (; i >= end; i -= step) {\n      arr.push(i);\n    }\n  }\n\n  return arr;\n};","map":null,"metadata":{},"sourceType":"script"}