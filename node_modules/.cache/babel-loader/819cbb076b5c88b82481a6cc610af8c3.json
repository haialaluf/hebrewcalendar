{"ast":null,"code":"/*\n\tHebcal - A Jewish Calendar Generator\n\tCopyright (C) 1994-2004  Danny Sadinoff\n\tPortions Copyright (c) 2002 Michael J. Radwin. All Rights Reserved.\n\n\thttps://github.com/hebcal/hebcal-js\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program. If not, see <http://www.gnu.org/licenses/>.\n\n\tDanny Sadinoff can be reached at danny@sadinoff.com\n\n\tMichael Radwin has made significant contributions as a result of\n\tmaintaining hebcal.com.\n\n\tThe JavaScript code was completely rewritten in 2014 by Eyal Schachter.\n */\nvar c = require('./common'),\n    HDate = require('./hdate'),\n    holidays = require('./holidays'),\n    Sedra = require('./sedra'),\n    dafyomi = require('./dafyomi'),\n    cities = require('./cities'),\n    greg = require('./greg'),\n    EventEmitter = require('events').EventEmitter,\n    gematriya = require('gematriya'); // for minifying optimizations\n\n\nvar defProp = Object.defineProperty,\n    TE = TypeError,\n    find = 'find',\n    strings = 'strings',\n    getYearObject = 'getYearObject',\n    map = 'map',\n    getDay = 'getDay',\n    getMonth = 'getMonth',\n    getFullYear = 'getFullYear',\n    isLeapYear = 'isLeapYear',\n    length = 'length',\n    next = 'next',\n    prev = 'prev',\n    months = c.months,\n    TISHREI = months.TISHREI,\n    NISAN = months.NISAN,\n    HebcalProto = Hebcal.prototype,\n    MonthProto = Month.prototype,\n    GregYearProto = GregYear.prototype,\n    GregMonthProto = GregMonth.prototype,\n    HDateProto = HDate.prototype;\n\nfunction getset(g, s) {\n  return {\n    enumerable: true,\n    configurable: true,\n    get: g,\n    set: s\n  };\n}\n\nfunction extend(base, into) {\n  for (var i in into) {\n    base[i] = into[i];\n  }\n\n  return base;\n} // Main Hebcal function\n\n\nfunction Hebcal(year, month) {\n  var me = this; // whenever this is done, it is for optimizations.\n\n  if (!year) {\n    year = new HDate()[getFullYear](); // this year;\n  }\n\n  if (typeof year !== 'number') {\n    throw new TE('year to Hebcal() is not a number');\n  }\n\n  me.year = year;\n\n  if (month) {\n    if (typeof month == 'string') {\n      month = c.monthFromName(month);\n    }\n\n    if (typeof month == 'number') {\n      month = [month];\n    }\n\n    if (Array.isArray(month)) {\n      me.months = month[map](function (i) {\n        var m = new Month(i, year);\n        defProp(m, '__year', {\n          configurable: true,\n          writable: true,\n          value: me\n        });\n        return m;\n      });\n      me.holidays = holidays.year(year);\n    } else {\n      throw new TE('month to Hebcal is not a valid type');\n    }\n  } else {\n    return new Hebcal(year, c.range(1, c.MONTH_CNT(year)));\n  }\n\n  me[length] = c.daysInYear(year);\n  defProp(me, 'il', getset(function () {\n    return me[getMonth](1).il;\n  }, function (il) {\n    me.months.forEach(function (m) {\n      m.il = il;\n    });\n  }));\n  defProp(me, 'lat', getset(function () {\n    return me[getMonth](1).lat;\n  }, function (lat) {\n    me.months.forEach(function (m) {\n      m.lat = lat;\n    });\n  }));\n  defProp(me, 'long', getset(function () {\n    return me[getMonth](1).long;\n  }, function (lon) {\n    me.months.forEach(function (m) {\n      m.long = lon;\n    });\n  }));\n}\n\nHebcalProto[isLeapYear] = HDateProto[isLeapYear];\n\nHebcalProto.setCity = function (city) {\n  this.months.forEach(function (m) {\n    m.setCity(city);\n  });\n  return this;\n};\n\nHebcalProto.setLocation = function (lat, lon) {\n  this.months.forEach(function (m) {\n    m.setLocation(lat, lon);\n  });\n  return this;\n};\n\nHebcalProto[next] = function () {\n  return new Hebcal(this.year + 1);\n};\n\nHebcalProto[prev] = function () {\n  return new Hebcal(this.year - 1);\n};\n\nHebcalProto[getMonth] = function (month) {\n  var months = this.months;\n  month = c.monthNum(month);\n\n  if (month > this.months[length]) {\n    return this[next]()[getMonth](month - months[length]);\n  }\n\n  return months[month > 0 ? month - 1 : months[length] + month];\n};\n\nHebcalProto[getDay] = function (day) {\n  var me = this;\n\n  if (day > me[length]) {\n    return null;\n  }\n\n  if (day < 0) {\n    return me[getDay](me[length] - day);\n  }\n\n  var rosh = me[find](29, months.ELUL)[0].abs() + 1 - me[find](1, NISAN)[0].abs(); // number of days between Nisan and Tishrei\n\n  if (day <= rosh) {\n    return me[getMonth](NISAN)[getDay](day);\n  }\n\n  return me[getMonth](TISHREI)[getDay](day - rosh);\n};\n\nHebcalProto.days = function () {\n  return [].concat.apply([], this.months[map](function (m) {\n    return m.days;\n  }));\n};\n\nHebcalProto[map] = function () {\n  return [][map].apply(this.days(), arguments);\n};\n\nHebcalProto.filter = function () {\n  return [].filter.apply(this.days(), arguments);\n};\n\nHebcalProto.addHoliday = function (holiday) {\n  if (!(holiday instanceof holidays.Event)) {\n    throw new TE('non-Event passed to addHoliday()');\n  }\n\n  this.holidays.add(holiday);\n  return this;\n};\n\nHebcalProto.findParsha = function (parsha, o) {\n  var langs = o ? [o] : ['s', 'a', 'h']; // FIXME: abstract this away somewhere\n\n  var days = this.filter(function (d) {\n    return Math.max.apply(null, langs.map(function (l) {\n      return d.getSedra(l).indexOf(parsha) + 1;\n    }));\n  });\n  return days[days[length] - 1];\n};\n\nHebcalProto.findSedra = HebcalProto.findParsha;\n\nHebcalProto[find] = function find_f(day, month) {\n  var me = this;\n\n  if (arguments[length] === 1) {\n    if (typeof day == 'string') {\n      return find_f[strings].call(me, day);\n    } else if (Array.isArray(day)) {\n      return [].concat.apply([], day[map](function (d) {\n        return me[find][Array.isArray(d) ? 'apply' : 'call'](me, d);\n      }));\n    } else if (day instanceof HDate) {\n      return me[find](day.getDate(), day[getMonth]());\n    } else if (day instanceof Date) {\n      return me[find](new HDate(day));\n    }\n  } else if (arguments[length] == 2) {\n    if (month instanceof Month) {\n      return month[find](day);\n    } else if (Array.isArray(month)) {\n      return [].concat.apply([], month[map](function (m) {\n        return me[find](day, m);\n      }));\n    } else if (typeof month == 'string') {\n      return me[find](day, c.monthNum(month));\n    } else if (typeof month == 'number') {\n      return me[find](day, me[getMonth](month));\n    }\n  }\n\n  return [];\n};\n\nHebcalProto[find][strings] = function strings(str) {\n  var split = str.split(/\\s+/),\n      func = strings[str.replace(/\\s/g, '_').toLowerCase()];\n\n  if (!split[length]) {\n    return [];\n  } else if (func) {\n    return func.call(this);\n  }\n\n  try {\n    return this[find](new HDate(str));\n  } catch (e) {\n    return split[length] - 1 ? this[find].apply(this, split) : [];\n  }\n};\n\nHebcalProto[find][strings].rosh_chodesh = function () {\n  return this[find]('Rosh Chodesh', c.range(1, this.months[length]));\n};\n\nHebcalProto[find][strings].holidays = function () {\n  return [].concat.apply([], this.holidays[map](function (h) {\n    return this[find](h.date);\n  }, this));\n};\n\nHebcalProto[find][strings].omer = function () {\n  return this[find](c.range(15 + 1, 15 + 49), NISAN);\n};\n\nHebcalProto[find][strings].today = function () {\n  return this[find](new HDate());\n};\n\nHebcalProto[find][strings].yesterday = function () {\n  return [this[find]('today')[0][prev]()];\n};\n\nHebcalProto[find][strings].tomorrow = function () {\n  return [this[find]('today')[0][next]()];\n};\n\nHebcalProto[find][strings].pesach = function () {\n  return this[find](c.range(15, 15 + 8 - this.il), NISAN);\n};\n\nHebcalProto[find][strings].sukkot = function () {\n  return this[find](c.range(15, 15 + 9 - this.il), TISHREI);\n};\n\nHebcalProto[find][strings].succot = HebcalProto[find][strings].succos = HebcalProto[find][strings].sukkos = HebcalProto[find][strings].sukkot;\n\nHebcalProto[find][strings].shavuot = function () {\n  return this[find](c.range(6, 7 - this.il), months.SIVAN);\n};\n\nHebcalProto[find][strings].shavuos = HebcalProto[find][strings].shavuot;\n\nHebcalProto[find][strings].rosh_hashana = function () {\n  return this[find](c.range(1, 2), TISHREI);\n};\n\nHebcalProto[find][strings].rosh_hashanah = HebcalProto[find][strings].rosh_hashana; // Hebcal properties\n\nHebcal.addZeman = HDate.addZeman;\nHebcal.cities = cities;\nHebcal.range = c.range;\nHebcal.gematriya = gematriya;\nHebcal.holidays = c.filter(holidays, ['masks', 'Event']); // not year(), atzmaut()\n\nHebcal.parshiot = Sedra.parshiot;\nHebcal.LANGUAGE = c.LANG;\nHebcal[map] = c[map];\nHebcal.filter = c.filter;\ndefProp(Hebcal, 'defaultLocation', getset(function () {\n  return HDate.defaultLocation;\n}, function (loc) {\n  Hebcal.events.emit('locationChange', HDate.defaultLocation);\n  HDate.defaultLocation = loc;\n}));\ndefProp(Hebcal, 'defaultCity', getset(function () {\n  return HDate.defaultCity;\n}, function (city) {\n  Hebcal.defaultLocation = cities.getCity(city).slice(0, 2); // call the event\n}));\ndefProp(Hebcal, 'candleLighting', getset(function () {\n  return holidays.Event.candleLighting;\n}, function (mins) {\n  holidays.Event.candleLighting = mins;\n}));\ndefProp(Hebcal, 'havdalah', getset(function () {\n  return holidays.Event.havdalah;\n}, function (mins) {\n  holidays.Event.havdalah = mins;\n})); // Months\n\nfunction Month(month, year) {\n  var me = this;\n  month = c.monthNum(month);\n\n  if (typeof month != 'number') {\n    throw new TE('month to Hebcal.Month is not a valid type');\n  }\n\n  if (typeof year != 'number') {\n    throw new TE('year to Hebcal.Month is not a number');\n  }\n\n  me.month = month;\n  me.year = year;\n  me.days = c.range(1, c.daysInMonth(month, year))[map](function (i) {\n    var d = new HDate(i, month, year);\n    defProp(d, '__month', {\n      configurable: true,\n      writable: true,\n      value: me\n    });\n    return d;\n  });\n  me[length] = me.days[length];\n  me.holidays = c.filter(holidays.year(year), function (h) {\n    return h[0].date[getMonth]() == month;\n  });\n  defProp(me, 'il', getset(function () {\n    return me[getDay](1).il;\n  }, function (il) {\n    me.days.forEach(function (d) {\n      d.il = il;\n    });\n  }));\n  defProp(me, 'lat', getset(function () {\n    return me[getDay](1).lat;\n  }, function (lat) {\n    me.days.forEach(function (d) {\n      d.lat = lat;\n    });\n  }));\n  defProp(me, 'long', getset(function () {\n    return me[getDay](1).long;\n  }, function (lon) {\n    me.days.forEach(function (d) {\n      d.long = lon;\n    });\n  }));\n  return me;\n}\n\n;\nHebcal.Month = Month;\nMonthProto[isLeapYear] = HDateProto[isLeapYear];\n\nMonthProto[prev] = function () {\n  var me = this,\n      year = me[getYearObject]();\n\n  if (me.month === 1) {\n    // Nisan\n    return year[getMonth](-1);\n  } else if (me.month === TISHREI) {\n    return year[prev]()[getMonth](months.ELUL);\n  } else {\n    return year[getMonth](me.month - 1);\n  }\n};\n\nMonthProto[next] = function () {\n  var me = this,\n      year = me[getYearObject]();\n\n  if (me.month === c.MONTH_CNT(me.year)) {\n    // Adar\n    return year[getMonth](1);\n  } else if (me.month === months.ELUL) {\n    return year[next]()[getMonth](TISHREI);\n  } else {\n    return year[getMonth](me.month + 1);\n  }\n};\n\nMonthProto[getDay] = function (day) {\n  var days = this.days;\n  day = c.dayYearNum(day);\n\n  if (day > days[length]) {\n    return this[next]()[getDay](day - days[length]);\n  }\n\n  return days[day > 0 ? day - 1 : days[length] + day];\n};\n\nMonthProto[getYearObject] = function () {\n  return this.__year || new Hebcal(this.year);\n};\n\nMonthProto.getName = function (o) {\n  return c.LANG(c.monthNames[+this[isLeapYear]()][this.month], o);\n};\n\nMonthProto.rosh_chodesh = function () {\n  var prevMonth = this[prev]();\n  return prevMonth[length] == 30 ? [prevMonth[getDay](-1), this[getDay](1)] : [this[getDay](1)];\n};\n\nMonthProto.setCity = function (city) {\n  this.days.forEach(function (d) {\n    d.setCity(city);\n  });\n  return this;\n};\n\nMonthProto.setLocation = function (lat, lon) {\n  this.days.forEach(function (d) {\n    d.setLocation(lat, lon);\n  });\n  return this;\n};\n\nMonthProto[map] = function () {\n  return [][map].apply(this.days, arguments);\n};\n\nMonthProto.molad = function () {\n  var retMolad = {},\n      year,\n      m_elapsed,\n      p_elapsed,\n      h_elapsed,\n      parts,\n      m_adj,\n      toInt = parseInt;\n  m_adj = this.month - 7;\n  year = this.year - 1;\n\n  if (m_adj < 0) {\n    m_adj += c.MONTH_CNT(year + 1);\n  }\n\n  m_elapsed = toInt(m_adj + 235 * (year / 19)\n  /* +\n  12 * (year % 19) +\n  (((year % 19) * 7) + 1) / 19*/\n  );\n  p_elapsed = toInt(204 + 793 * (m_elapsed % 1080));\n  h_elapsed = toInt(5 + 12 * m_elapsed + 793 * (m_elapsed / 1080)\n  /* +\n  p_elapsed / 1080*/\n  - 6);\n  parts = toInt(p_elapsed % 1080 + 1080 * (h_elapsed % 24));\n  retMolad.doy = new HDate(toInt(1 + 29 * m_elapsed + h_elapsed / 24)).getDay();\n  retMolad.hour = Math.round(h_elapsed % 24);\n  var chalakim = toInt(parts % 1080);\n  retMolad.minutes = toInt(chalakim / 18);\n  retMolad.chalakim = chalakim % 18;\n\n  var day = this.prev().find.strings.shabbat_mevarchim._calc.call(this)[0].onOrAfter(retMolad.doy).greg();\n\n  day.setHours(retMolad.hour);\n  day.setMinutes(retMolad.minutes);\n  day.setSeconds(retMolad.chalakim * 3.33);\n  retMolad.day = day;\n  return retMolad;\n};\n\nMonthProto[find] = function find_f(day) {\n  var me = this;\n\n  if (typeof day == 'number') {\n    return [me[getDay](day)];\n  } else if (typeof day == 'string') {\n    return find_f[strings].call(me, day);\n  } else if (Array.isArray(day)) {\n    return [].concat.apply([], day[map](function (d) {\n      return me[find](d);\n    }));\n  } else if (day instanceof HDate && day[getFullYear]() == me.year && day[getMonth]() == me.month) {\n    return me[find](day.getDate());\n  } else if (day instanceof Date) {\n    return me[find](new HDate(day));\n  }\n\n  return [];\n};\n\nMonthProto[find][strings] = function strings(str) {\n  var func = strings[str.replace(/\\s/g, '_').toLowerCase()];\n\n  if (func) {\n    return func.call(this);\n  }\n\n  try {\n    return this[find](new HDate(str));\n  } catch (e) {\n    var num = c.dayYearNum(str);\n    return num ? this[find](num) : [];\n  }\n};\n\nMonthProto[find][strings].rosh_chodesh = function () {\n  return this.rosh_chodesh();\n};\n\nMonthProto[find][strings].shabbat_mevarchim = function sm() {\n  return this.month === months.ELUL ? [] : // No birchat hachodesh in Elul\n  sm._calc.call(this);\n};\n\nMonthProto[find][strings].shabbat_mevarchim._calc = function () {\n  return this[find](this[getDay](29).onOrBefore(c.days.SAT));\n};\n\nMonthProto[find][strings].shabbos_mevarchim = MonthProto[find][strings].shabbos_mevorchim = MonthProto[find][strings].shabbat_mevarchim; // HDate days\n\nHebcal.HDate = HDate;\n\nHDateProto.getMonthObject = function () {\n  return this.__month || new Month(this[getMonth](), this[getFullYear]());\n};\n\nHDateProto[getYearObject] = function () {\n  return this.getMonthObject()[getYearObject]();\n};\n\n(function () {\n  var orig = {}; // slightly less overhead when using unaffiliated HDate()s\n\n  [prev, next].forEach(function (func) {\n    orig[func] = HDateProto[func];\n\n    HDateProto[func] = function () {\n      var day = orig[func].call(this);\n\n      if (!this.__month) {\n        return day;\n      }\n\n      return this[getYearObject]()[find](day)[0];\n    };\n  });\n})();\n\nvar _getCachedSedraYear = function () {\n  var __cache = {};\n  return function (hd) {\n    var sedraYear = __cache[hd[getFullYear]()];\n\n    if (!sedraYear || sedraYear.il != hd.il) {\n      sedraYear = __cache[hd[getFullYear]()] = new Sedra(hd[getFullYear](), hd.il);\n    }\n\n    return sedraYear;\n  };\n}();\n\nHDateProto.getSedra = function (o) {\n  var sedraYear = _getCachedSedraYear(this);\n\n  return sedraYear.get(this)[map](function (p) {\n    return c.LANG(p, o);\n  });\n};\n\nHDateProto.getParsha = HDateProto.getSedra;\n\nHDateProto.isSedra = function () {\n  var sedraYear = _getCachedSedraYear(this);\n\n  return sedraYear.isParsha(this);\n};\n\nHDateProto.isParsha = HDateProto.isSedra;\n\nHDateProto.holidays = function (all) {\n  var me = this,\n      days = me[getYearObject]().holidays[me];\n  return days ? days.filter(function (h) {\n    return all ? true : !h.routine() && h.is(me);\n  })[map](function (h) {\n    h.date.setLocation(me);\n    return h;\n  }) : [];\n};\n\n['candleLighting', 'havdalah'].forEach(function (prop) {\n  HDateProto[prop] = function () {\n    var me = this,\n        hd = me.holidays(true).filter(function (h) {\n      return h.is(me);\n    });\n\n    if (hd.length) {\n      hd = c.filter(hd.map(function (h) {\n        return h[prop]();\n      }), true);\n    }\n\n    return hd.length ? new Date(Math.max.apply(null, hd)) : null;\n  };\n});\n\nHDateProto.omer = function () {\n  var me = this,\n      greg = me.greg().getTime(),\n      year = me[getFullYear]();\n\n  if (greg > new HDate(15, NISAN, year).greg().getTime() && greg < new HDate(6, months.SIVAN, year).greg().getTime()) {\n    return me.abs() - new HDate(16, NISAN, year).abs() + 1;\n  }\n\n  return 0;\n};\n\nHDateProto.dafyomi = function (o) {\n  return dafyomi.dafname(dafyomi.dafyomi(this.greg()), o);\n};\n\nHDateProto.tachanun = function () {\n  var NONE = tachanun.NONE = 0,\n      MINCHA = tachanun.MINCHA = 1,\n      SHACHARIT = tachanun.SHACHARIT = 2,\n      ALL_CONGS = tachanun.ALL_CONGS = 4;\n  var __cache = {\n    all: {},\n    some: {},\n    yes_prev: {},\n    il: {}\n  };\n\n  function tachanun() {\n    var checkNext = !arguments[0],\n        me = this;\n    var year = me[getYearObject](),\n        y = year.year;\n\n    function mapAbs(arr) {\n      return arr[map](function (d) {\n        return d.abs();\n      });\n    }\n\n    var all, some, yes_prev;\n\n    if (__cache.il[y] === me.il) {\n      all = __cache.all[y];\n      some = __cache.some[y];\n      yes_prev = __cache.yes_prev[y];\n    } else {\n      all = __cache.all[y] = mapAbs(year[find]('Rosh Chodesh').concat(year[find](c.range(1, c.daysInMonth(NISAN, y)), NISAN), // all of Nisan\n      year[find](15 + 33, NISAN), // Lag Baomer\n      year[find](c.range(1, 8 - me.il), months.SIVAN), // Rosh Chodesh Sivan thru Isru Chag\n      year[find]([9, 15], months.AV), // Tisha B'av and Tu B'av\n      year[find](-1, months.ELUL), // Erev Rosh Hashanah\n      year[find]([1, 2], TISHREI), // Rosh Hashanah\n      year[find](c.range(9, 24 - me.il), TISHREI), // Erev Yom Kippur thru Isru Chag\n      year[find](c.range(25, 33), months.KISLEV), // Chanukah\n      year[find](15, months.SHVAT), // Tu B'shvat\n      year[find]([14, 15], year[isLeapYear]() ? [months.ADAR_I, months.ADAR_II] : months.ADAR_I) // Purim/Shushan Purim + Katan\n      ));\n      some = __cache.some[y] = mapAbs([].concat( // Don't care if it overlaps days in all, because all takes precedence\n      year[find](c.range(1, 13), months.SIVAN), // Until 14 Sivan\n      year[find](c.range(20, 31), TISHREI), // Until after Rosh Chodesh Cheshvan\n      year[find](14, months.IYYAR), // Pesach Sheini\n      holidays.atzmaut(y)[1].date || [], // Yom HaAtzma'ut, which changes based on day of week\n      y >= 5727 ? year[find](29, months.IYYAR) : [] // Yom Yerushalayim\n      ));\n      yes_prev = __cache.yes_prev[y] = mapAbs([].concat( // tachanun is said on the previous day at mincha\n      year[find](-1, months.ELUL), // Erev Rosh Hashanah\n      year[find](9, months.TISHREI), // Erev Yom Kippur\n      year[find](14, months.IYYAR) // Pesach Sheini\n      ));\n      __cache.il[y] = me.il;\n    }\n\n    all = all.indexOf(me.abs()) > -1;\n    some = some.indexOf(me.abs()) > -1;\n    yes_prev = yes_prev.indexOf(me.abs() + 1) > -1;\n\n    if (all) {\n      return NONE;\n    }\n\n    var ret = (!some && ALL_CONGS) | (me[getDay]() != 6 && SHACHARIT);\n\n    if (checkNext && !yes_prev) {\n      ret |= me[next]().tachanun(true) & SHACHARIT && MINCHA;\n    } else {\n      ret |= me[getDay]() != 5 && MINCHA;\n    }\n\n    return ret == ALL_CONGS ? NONE : ret;\n  }\n\n  return tachanun;\n}();\n\nHDateProto.tachanun_uf = function () {\n  var ret = this.tachanun();\n  return {\n    shacharit: !!(ret & this.tachanun.SHACHARIT),\n    mincha: !!(ret & this.tachanun.MINCHA),\n    all_congs: !!(ret & this.tachanun.ALL_CONGS)\n  };\n};\n\nHDateProto.hallel = function () {\n  var NONE = hallel.NONE = 0,\n      HALF = hallel.HALF = 1,\n      WHOLE = hallel.WHOLE = 2;\n  var __cache = {\n    whole: {},\n    half: {},\n    il: {}\n  };\n\n  function hallel() {\n    var me = this,\n        year = me[getYearObject](),\n        y = year.year;\n    var whole = __cache.il[y] == me.il && __cache.whole[y] || (__cache.whole[y] = [].concat(year[find](c.range(25, 33), months.KISLEV), // Chanukah\n    year[find]([15, me.il ? null : 16], NISAN), // First day(s) of Pesach\n    year[find]('Shavuot'), year[find]('Sukkot'), holidays.atzmaut(y)[1].date || [], // Yom HaAtzma'ut, which changes based on day of week\n    y >= 5727 ? year[find](29, months.IYYAR) : [] // Yom Yerushalayim\n    )[map](function (d) {\n      return d.abs();\n    }));\n    var half = __cache.il[y] == me.il && __cache.half[y] || (__cache.half[y] = [].concat(year[find]('Rosh Chodesh').filter(function (rc) {\n      return rc[getMonth]() != TISHREI;\n    }), // Rosh Chodesh, but not Rosh Hashanah\n    year[find](c.range(17 - me.il, 23 - me.il), NISAN) // Last six days of Pesach\n    )[map](function (d) {\n      return d.abs();\n    }));\n    __cache.il[y] = me.il;\n    return whole.indexOf(me.abs()) > -1 && WHOLE || half.indexOf(me.abs()) > -1 && HALF || NONE;\n  }\n\n  return hallel;\n}(); // Events\n\n\n(function (events) {\n  var refreshInterval,\n      refresh,\n      today = new HDate();\n  defProp(events, 'refreshInterval', getset(function () {\n    return refreshInterval;\n  }, function (ms) {\n    if (refresh) {\n      refresh = clearInterval(refresh);\n    }\n\n    refreshInterval = ms;\n\n    if (ms) {\n      refresh = setInterval(checkTimes, ms);\n\n      if (refresh.unref) {\n        refresh.unref(); // don't keep the process open\n      }\n    }\n  }));\n  events.beforeZeman = 1000 * 60 * 10; // 10 minutes\n\n  function checkTimes() {\n    var now = new HDate();\n\n    if (!today.isSameDate(now)) {\n      events.emit('dayChange');\n      today = now;\n    }\n\n    function close(obj, compare) {\n      return c.filter(c[map](obj, function (time) {\n        return time - nowGreg;\n      }), function (time) {\n        return time > 0 && time - compare < 0;\n      });\n    }\n\n    var nowGreg = new Date(),\n        almostTime = close(now.getZemanim(), events.beforeZeman),\n        customTimes = close(events.customs, events.refreshInterval);\n\n    for (var zeman in almostTime) {\n      events.emit('almostZeman', zeman, almostTime[zeman]);\n\n      if (almostTime[zeman] < events.refreshInterval) {\n        events.emit('atZeman', zeman);\n      }\n    }\n\n    for (var custom in customTimes) {\n      events.emit('custom', custom);\n    }\n  }\n\n  checkTimes();\n  events.refreshInterval = 1000 * 60 * 5; // 5 minutes\n  // set the interval\n\n  events.customs = {};\n})(Hebcal.events = new EventEmitter()); // Gregorian years\n\n\nfunction GregYear(year, month) {\n  var me = this;\n\n  if (!year) {\n    year = new Date()[getFullYear]();\n  }\n\n  if (typeof year === 'string') {\n    var d = new Date(year);\n    month = year.indexOf(' ') + 1 || year.indexOf('-') + 1 || year.indexOf('/') + 1 ? d[getMonth]() + 1 : c.range(1, 12); // Check if a month was passed in the string. Can't just check for default January, because a real January might have been passed.\n\n    return new GregYear(d[getFullYear](), month);\n  }\n\n  if (typeof year !== 'number') {\n    throw new TE('year to Hebcal.GregYear() is not a number');\n  }\n\n  me.year = year;\n\n  if (month) {\n    if (typeof month === 'string') {\n      // month name\n      month = greg.lookupMonthName(month);\n    }\n\n    if (typeof month === 'number') {\n      month = [month];\n    }\n\n    if (Array.isArray(month)) {\n      me.months = month[map](function (i) {\n        var m = new GregMonth(i, year);\n        defProp(m, '__year', {\n          configurable: true,\n          writable: true,\n          value: me\n        });\n        return m;\n      });\n    } else {\n      throw new TE('month to Hebcal.GregYear() is not a valid type');\n    }\n  } else {\n    return new GregYear(year, c.range(1, 12));\n  }\n\n  me.hebyears = [].concat.apply([], me.months[map](function (m) {\n    return m.hebmonths[map](function (hm) {\n      return hm.year;\n    });\n  })).filter(function (val, i, arr) {\n    return arr.indexOf(val) === i; // keep unique values only\n  });\n  me.holidays = c.filter(holidays.year(me.hebyears[0]), function (h) {\n    return h[0].date.greg()[getFullYear]() === year && me.months.filter(function (m) {\n      // don't keep ones that are out of bounds\n      return m.month === h[0].date.greg()[getMonth]() + 1;\n    })[length];\n  });\n\n  if (me.hebyears[1]) {\n    extend(me.holidays, c.filter(holidays.year(me.hebyears[1]), function (h) {\n      return h[0].date.greg()[getFullYear]() === year && me.months.filter(function (m) {\n        // don't keep ones that are out of bounds\n        return m.month === h[0].date.greg()[getMonth]() + 1;\n      })[length];\n    }));\n  }\n\n  me[length] = 365 + greg.LEAP(year);\n  defProp(me, 'il', getset(function () {\n    return me[getMonth](1).il;\n  }, function (il) {\n    me.months.forEach(function (m) {\n      m.il = il;\n    });\n  }));\n  defProp(me, 'lat', getset(function () {\n    return me[getMonth](1).lat;\n  }, function (lat) {\n    me.months.forEach(function (m) {\n      m.lat = lat;\n    });\n  }));\n  defProp(me, 'long', getset(function () {\n    return me[getMonth](1).long;\n  }, function (lon) {\n    me.months.forEach(function (m) {\n      m.long = lon;\n    });\n  }));\n  return me;\n}\n\n;\nHebcal.GregYear = GregYear;\n\nGregYearProto[isLeapYear] = function () {\n  return this[length] == 366;\n};\n\nGregYearProto.setCity = HebcalProto.setCity;\nGregYearProto.setLocation = HebcalProto.setLocation;\n\nGregYearProto[next] = function () {\n  return new GregYear(this.year + 1);\n};\n\nGregYearProto[prev] = function () {\n  return new GregYear(this.year - 1);\n};\n\nGregYearProto[getMonth] = function (month) {\n  var months = this.months;\n  month = typeof month == 'number' ? month : greg.lookupMonthNum(month);\n\n  if (month > months[length]) {\n    return this[next]()[getMonth](month - months[length]);\n  }\n\n  return months[month > 0 ? month - 1 : months[length] + month];\n};\n\nextend(GregYearProto, {\n  days: HebcalProto.days,\n  map: HebcalProto[map],\n  filter: HebcalProto.filter,\n  addHoliday: HebcalProto.addHoliday\n});\n/*GregYearProto.days = HebcalProto.days;\nGregYearProto[map] = HebcalProto[map];\nGregYearProto.filter = HebcalProto.filter;\n\nGregYearProto.addHoliday = HebcalProto.addHoliday;*/\n\nfunction GregMonth(month, year) {\n  var me = this;\n\n  if (typeof month == 'string') {\n    month = greg.lookupMonthNum(month);\n  }\n\n  if (typeof month != 'number') {\n    throw new TE('month to Hebcal.GregMonth is not a valid type');\n  }\n\n  if (typeof year != 'number') {\n    throw new TE('year to Hebcal.GregMonth is not a number');\n  }\n\n  me.year = year;\n  me.month = month;\n  me.days = c.range(1, greg.daysInMonth(month, year))[map](function (i) {\n    var d = new HDate(new Date(year, month - 1, i));\n    defProp(d, '__gregmonth', {\n      configurable: true,\n      writable: true,\n      value: me\n    });\n    return d;\n  });\n  me[length] = me.days[length];\n  me.hebmonths = [{\n    month: me[getDay](1)[getMonth](),\n    year: me[getDay](1)[getFullYear]()\n  }, {\n    month: me[getDay](-1)[getMonth](),\n    year: me[getDay](-1)[getFullYear]()\n  }].filter(function (val, i, arr) {\n    return i === 0 || val.month != arr[0].month;\n  });\n  defProp(me, 'il', getset(function () {\n    return me[getDay](1).il;\n  }, function (il) {\n    me.days.forEach(function (d) {\n      d.il = il;\n    });\n  }));\n  defProp(me, 'lat', getset(function () {\n    return me[getDay](1).lat;\n  }, function (lat) {\n    me.days.forEach(function (d) {\n      d.lat = lat;\n    });\n  }));\n  defProp(me, 'long', getset(function () {\n    return me[getDay](1).long;\n  }, function (lon) {\n    me.days.forEach(function (d) {\n      d.long = lon;\n    });\n  }));\n  return me;\n}\n\n;\nHebcal.GregMonth = GregMonth;\n\nGregMonthProto[isLeapYear] = function () {\n  return greg.LEAP(this.year);\n};\n\nGregMonthProto[prev] = function () {\n  if (this.month === 1) {\n    return this[getYearObject]()[prev]()[getMonth](-1);\n  } else {\n    return this[getYearObject]()[getMonth](this.month - 1);\n  }\n};\n\nGregMonthProto[next] = function () {\n  return this[getYearObject]()[getMonth](this.month + 1);\n};\n\nGregMonthProto[getDay] = function (day) {\n  if (day > this.days[length]) {\n    return this[next]()[getDay](day - this.days[length]);\n  }\n\n  return this.days[day > 0 ? day - 1 : this.days[length] + day];\n};\n\nGregMonthProto[getYearObject] = function () {\n  return this.__year || new GregYear(this.year);\n};\n\nGregMonthProto.getName = function () {\n  return greg.monthNames[this.month];\n};\n\nGregMonthProto.setCity = MonthProto.setCity;\nGregMonthProto.setLocation = MonthProto.setLocation;\nGregMonthProto[map] = MonthProto[map];\n\nHDateProto.getGregMonthObject = function () {\n  return this.__gregmonth || new GregMonth(this.greg()[getMonth]() + 1, this.greg()[getFullYear]());\n};\n\nHDateProto.getGregYearObject = function () {\n  return this.getGregMonthObject()[getYearObject]();\n};\n\nmodule.exports = Hebcal;","map":null,"metadata":{},"sourceType":"script"}